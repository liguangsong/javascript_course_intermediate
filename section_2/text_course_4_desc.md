上一章讲了类和对象，但是没讲怎么自定义一个类，因为要用到this的知识点。所以我们放到这里讲。

一个典型的定义类的方法

    function Car(x,y){ 
        this.x = x;
        this.y = y;
        this.run = function(x_increase, y_increase){
            this.x += x_increase;
            this.y += y_increase;
        }
        this.show = function(){
            console.log("( " + this.x + "," + this.y + " )");
        }
    }
    
通过上述代码，我们就拥有了一个名为Car的“类”。它有两个成员变量x和y还有一个成员函数run。那么我们就可以像用Object一样使用它：

    var a_car = new Car(2,4); //获得了一个坐标为(2,4)的Car对象，x为2，y为9
    a_car.run(10,5);          //a_car.x变成了12，a_car.y变成了9
    a_car.show();             //打印结果为 ( 12,9 )
    
当我们使用new Car(2,4)的时候，就会生成一个对象，在调用的过程中会调用所谓的构造函数。而在本页第一段代码中的Car函数就是一个构造函数。

它为什么既是一个类，又是一个构造函数呢？
严格的讲，他应该是相当于一个类。因为在js世界里，在ES6标准之前，是没有语法级别的类的。
但是类又是常用的一种思维方式，所以我们这里说，它相当于一个类。

至于JS世界的对象系统到底是什么样子的呢，我们在下一节去讲。

使用这种方式去自定义类，所有的成员定义都放在构造函数里，不论函数还是属性。这样做的话，每次构造一个对象，都要对所有的函数重新分配内存。
比如

    var a_car = new Car(2,4);
    var b_car = new Car(3,3);
    
上面的代码new了两次，相应的run和show被分配了两次内存。除了所属的对象不同，两组函数并没有什么区别。
所以对于一般的场景来说，分配两次内存并没什么必要。至于省内存的作法，我们在下一节讲。